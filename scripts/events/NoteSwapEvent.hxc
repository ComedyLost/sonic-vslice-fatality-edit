import funkin.play.PlayState;
import funkin.play.event.ScriptedSongEvent;

import funkin.modding.module.Module;
import funkin.modding.module.ModuleHandler;
import funkin.play.scoring.Scoring;
import funkin.Preferences;
import funkin.FunkinMemory;

import funkin.Highscore;

import funkin.util.Constants;

import funkin.Paths;
import flixel.FlxG;

import funkin.mobile.input.ControlsHandler;

import funkin.data.notestyle.NoteStyleRegistry;
import funkin.play.notes.notestyle.NoteStyle;
import funkin.play.notes.notekind.NoteKindManager;
import funkin.play.notes.NoteSplash;
import funkin.play.notes.Strumline;
import funkin.play.notes.StrumlineNote;
import funkin.play.notes.NoteHoldCover;
import funkin.play.notes.NoteSprite;
import funkin.play.components.PopUpStuff;
import funkin.util.PlatformUtil;

class NoteSwapEvent extends ScriptedSongEvent {

	public override function handleEvent(data) {
		if (PlayState.instance == null || PlayState.instance.currentStage == null) return;
		if (PlayState.instance.isMinimalMode) return;

        switch(data.value.strumline) {
			case 'playerStrumline':
                ModuleHandler.getModule('SwappingNotestyles').scriptCall('swapPlayerStrumlines', [data.value.notestyle]);
            case 'opponentStrumline':
                ModuleHandler.getModule('SwappingNotestyles').scriptCall('swapOpponentStrumlines', [data.value.notestyle]);
            case 'both':
                ModuleHandler.getModule('SwappingNotestyles').scriptCall('swapStrumlines', [data.value.notestyle]);
            } 
	}

	public function getEventSchema() {
        var noteStyles = ["Funkin'" => "funkin", "Pixel" => "pixel"];
		var noteStyleIds:Array<String> = NoteStyleRegistry.instance.listEntryIds();
	
		for (noteStyleId in noteStyleIds)
		{
		  var noteStyle:Null<NoteStyle> = NoteStyleRegistry.instance.fetchEntry(noteStyleId);
		  if (noteStyle == null) continue;
		  noteStyles.set(noteStyle.getName(), noteStyleId);
		}
		return [
            {
                name: "strumline",
                title: "Strumline",
                defaultValue: "playerStrumline",
				type: "enum",
				keys: [
					"Player" => "playerStrumline",
                    "Opponent" => "opponentStrumline",
                    "Both" => "both"
				]
            },
            {
                name: "notestyle",
                title: "Notestyle",
                defaultValue: "funkin",
                type: "enum",
                keys: noteStyles,
            }
		];
	}

	public function getTitle() {
		return "Notestyle Swapper";
	}
	
	public function new() {
		super('NoteSwapEvent');
	}
}

class SwappingNotestyles extends Module
{
	function new()
	{
		super('SwappingNotestyles');
	}

	override function onSongLoaded(event) {
		super.onSongLoaded(event);
		var cachedStyles:Array<String> = [];
		var noteStyleIds:Array<String> = NoteStyleRegistry.instance.listEntryIds();
		for (events in event.events){
			if (events.eventKind == 'NoteSwapEvent'){
				if (NoteStyleRegistry.instance.fetchEntry(events.value.notestyle) != null && !cachedStyles.contains(events.value.notestyle)){
					cachedStyles.push(events.value.notestyle);
					var notestyle = NoteStyleRegistry.instance.fetchEntry(events.value.notestyle);
					FunkinMemory.cacheNoteStyle(notestyle); // I love you Funkin Team
				}
			}
		}
	}	

	var hasTriggeredEvent:Bool = false; // Coders can force a reload
	
	public override function onSongEvent(scriptEvent:SongEventScriptEvent) {
		super.onSongEvent(scriptEvent);
		if (scriptEvent.eventData.eventKind == "NoteSwapEvent") {
			if (!scriptEvent.eventCanceled) hasTriggeredEvent = true; // Only reset if event wasn't canceled
		}
	}	

    function swapPlayerStrumlines(stylePlayer:String){
		newPopUps(stylePlayer);
		setupNotes(PlayState.instance.playerStrumline, stylePlayer);
	}

	function swapOpponentStrumlines(styleOpponent:String){
		setupNotes(PlayState.instance.opponentStrumline, styleOpponent);
	}

	function swapStrumlines(style:String){
		newPopUps(style);
		setupNotes(PlayState.instance.playerStrumline, style);
		setupNotes(PlayState.instance.opponentStrumline, style);
	}

	function newPopUps(newComboStyle:String){
		var noteStyleId:String = newComboStyle;
		var noteStyle:NoteStyle = NoteStyleRegistry.instance.fetchEntry(noteStyleId) ?? NoteStyleRegistry.instance.fetchDefault();
		// Initialize the judgements and combo meter.
		PlayState.instance.comboPopUps.noteStyle = noteStyle;
	}

	function setupNotes(strumline:Strumline, style:String){
		var noteStyleId:String = style;
		var noteStyle:NoteStyle = NoteStyleRegistry.instance.fetchEntry(noteStyleId) ?? NoteStyleRegistry.instance.fetchDefault();
		var ogNoteStyle = strumline.noteStyle;
		strumline.noteStyle = noteStyle;
		//Clear all notesplashes and hold covers so the game can make new ones (Do this first so I can redo these with the notes)
		strumline.noteSplashes.clear();
		strumline.noteHoldCovers.clear();
		for (i in 0...Strumline.KEY_COUNT) {
			strumline.strumlineNotes.members[i].kill();
			strumline.strumlineNotes.remove(strumline.strumlineNotes.members[i]);
			var child:StrumlineNote = new StrumlineNote(noteStyle, strumline.isPlayer, Strumline.DIRECTIONS[i]);
			child.x = strumline.getXPos(Strumline.DIRECTIONS[i]);
			child.x += Strumline.INITIAL_OFFSET;
			child.y = 0;
			noteStyle.applyStrumlineOffsets(child);
			strumline.strumlineNotes.add(child);
		}		
		for (notes in strumline.notes) {
			var noteKindStyle:NoteStyle = NoteKindManager.getNoteStyle(notes.kind, strumline.noteStyle.id) ?? noteStyle;
			notes.setupNoteGraphic(noteKindStyle);
			notes.playNoteAnimation(notes.noteData.getDirection());
			if (notes.get_isHoldNote()) {
				notes.holdNoteSprite.setupHoldNoteGraphic(noteStyle);
				notes.holdNoteSprite.noteStyleOffsets = noteStyle.getHoldNoteOffsets();
				notes.holdNoteSprite.graphicWidth = notes.holdNoteSprite.graphic.width / 8 * notes.holdNoteSprite.zoom; // amount of notes * 2
				notes.holdNoteSprite.graphicHeight = notes.holdNoteSprite.sustainLength * Constants.PIXELS_PER_MS * strumline?.scrollSpeed ?? 1.0;			
	
				notes.holdNoteSprite.updateHitbox();	
				notes.holdNoteSprite.updateClipping();
				notes.holdNoteSprite.updateColorTransform();
	
				//Recenter hold notes
				notes.holdNoteSprite.x = strumline.x;
				notes.holdNoteSprite.x += strumline.getXPos(Strumline.DIRECTIONS[notes.noteData.getDirection() % Strumline.KEY_COUNT]);
				notes.holdNoteSprite.x += Strumline.STRUMLINE_SIZE / 2;
				notes.holdNoteSprite.x -= notes.holdNoteSprite.graphicWidth / 2;	

				//Replay hold cover anim
				if (notes.holdNoteSprite.hitNote){
					strumline.playNoteHoldCover(notes.holdNoteSprite);
				}
			}
			strumline.onNoteIncoming.dispatch(notes); //Restarts just in case a note uses it
		}
		if (FlxG.onMobile) { // Fix the strumline to work on mobile
			if (strumline == PlayState.instance.opponentStrumline) fixOpponentStrumline();
			else fixPlayerStrumline();
		}
	}

	function fixOpponentStrumline() {
		if (!ControlsHandler.usingExternalInputDevice) {
			var opponentStrumline = PlayState.instance.opponentStrumline;

			var amplification:Float = (FlxG.width / FlxG.height) / (FlxG.initialWidth / FlxG.initialHeight);
			var playerStrumlineScale:Float = ((FlxG.height / FlxG.width) * 1.95) * amplification;
			var playerNoteSpacing:Float = ((FlxG.height / FlxG.width) * 2.8) * amplification;

			opponentStrumline.enterMiniMode(0.4 * amplification);

			/*opponentStrumline.y = Constants.STRUMLINE_Y_OFFSET * 0.3;
			opponentStrumline.x -= 30;*/
		}
	}

	function fixPlayerStrumline() {
		if (!ControlsHandler.usingExternalInputDevice) {
			var playerStrumline = PlayState.instance.playerStrumline;

			var amplification:Float = (FlxG.width / FlxG.height) / (FlxG.initialWidth / FlxG.initialHeight);
			var playerStrumlineScale:Float = ((FlxG.height / FlxG.width) * 1.95) * amplification;
			var playerNoteSpacing:Float = ((FlxG.height / FlxG.width) * 2.8) * amplification;

			playerStrumline.ghostTapTimer = 0; // Re-allow ghost tapping
			playerStrumline.strumlineScale.set(playerStrumlineScale, playerStrumlineScale);
			playerStrumline.setNoteSpacing(playerNoteSpacing);
			for (strum in playerStrumline) {
		  		strum.width *= 2;
			}

			/*playerStrumline.y = (FlxG.height - playerStrumline.height) * 0.95 - Constants.STRUMLINE_Y_OFFSET;
			if (playerStrumline.noteStyle.id.toLowerCase() != "pixel") {
		  		if (PlatformUtil.detectHostPlatform == 'ANDROID') playerStrumline.y += 10; // Why tf is this hard-coded?
			} else {
				playerStrumline.y -= 10;
			}*/
			PlayState.instance.hitbox.isPixel = playerStrumline.noteStyle.id.toLowerCase() == "pixel";
			if (Preferences.controlsScheme == 'Arrows') {
				for (direction in Strumline.DIRECTIONS) {
        			PlayState.instance.hitbox.getFirstHintByDirection(direction).follow(PlayState.instance.playerStrumline.getByDirection(direction));
        		}
			}
		}
	}

	override function onSongRetry(event) {
		super.onSongRetry(event);
		if (hasTriggeredEvent) {
			swapStrumlines(PlayState.instance.currentChart.noteStyle, true);
			hasTriggeredEvent = false;
		}
	}	
}